## 📆 2021-08-30(월) TIL

### 📈 어제의 계획이 예상대로 진행됐나요?
- [x] 오브젝트 8장 읽기 및 스터디 참여
- [x] [ReScript 공식 문서 lazy value, async & promise](https://github.com/saseungmin/Learn_ReScript_with_Official_Documentation)

### 🦄 이번주 목표 진행사항은요? (오늘 조금이라도 진행했으면 체크)
- [x] 회사 문화에 적응하기
- [x] 스터디 참여 및 오브젝트 10장까지 읽기
- [ ] 스터디를 위한 자바스크립트 코딩의 기술 훑어보기
- [x] ReScript 공식 문서 훑어보기
- [ ] 블로그에 이직 후기 회고 작성

### 🤔 공부하면서 배운것이 있다면?

#### 🎈 오브젝트 8장
- 클래스가 특정한 문맥에 강하게 결합될수록 다른 문맥에서 사용하기는 더 어려워진다. 클래스가 사용될 특정한 문맥에 대해 최소한의 가정만으로 이뤄져 있다면 다른 문맥에서 재사용하기가 더 수월해진다. 이를 컨텍스트 독립성이라고 한다.
- 설계가 유연해지기 위해서는 가능한 한 자신이 실행된 컨텍스트에 대한 구체적인 정보를 최대한 적게 알아야 한다.
- 컴파일타임 의존성은 구체적인 런타임 의존성으로 대체돼야 한다. 컴파일타임 의존성을 실행 컨텍스트에 맞는 적절한 런타임 의존성으로 교체하는 것을 의존성 해결이라고 부른다.
- 추상화를 사용하면 현재 다루가 있는 문제를 해결하는 데 불필요한 정보를 감출 수 있다. 따라서 대상에 대해 알아야 하는 지식의 양을 줄일 수 있기 때문에 결합도를 느슨하게 유지할 수 있다.
- `new`는 해롭다. 결합도 측면에서 `new`가 해로운 이유는 크게 두 가지이다. 
  1. `new` 연산자를 사용하기 위해서는 구체 클래스의 이름을 직접 기술해야 한다.
  2. `new` 연산자는 생성하려는 구체 클래스뿐만 아니라 어떤 인자를 이용해 클래스의 생성자를 호출해야 하는지도 알아야 한다. 따라서 `new`를 사용하면 클라이언트가 알아야 하는 지식의 양이 늘어나기 때문에 결합도가 높아진다.
- 해결 방법은 인스턴스를 생성하는 로직과 생성된 인스턴스를 사용하는 로직을 분리하는 것이다. 
- 자바라면 JDK에 포함된 표준 클래스 즉, 변경될 확률이 거의 없는 클래스는 의존성에 문제가 되지 않는다. 표준 클래스에 대한 의존은 해롭지 않다.

#### 🎈 ReScript
##### Lazy Value
- 지연된 값은 나중에 계산하는 것을 표현
- 자동으로 첫번째 실행결과를 기억해준다. 그리고 어떤 반복된 실행의 결과를 기억한 값을 리턴한다.
- 항상 같은 값을 반환하는 복잡한 함수와 식을 정의하는 데에 유용하다.
- 지연된 값은 `Lazy.t('a)`타입을 가지고 있다. `'a`는 계산된 결과값을 리턴할 값의 타입이다.
- 모든 기능들은 전역으로 사용 가능한 Lazy 모듈에 캡슐화되어있다.
- 리스크립트는 지연된 값을 만드는 문법을 제공한다. `lazy` 키워드를 사용해 지연된 값을 만들 표현식을 작성할 수 있다.

```reason
let getFiles = 
  lazy({
    Js.log("Reading dir")
    Node.Fs.readdirSync("./pages")
  })

// 첫번째 호출시, 계산을 수행
Lazy.force(getFiles) -> Js.log

// 두번째 호출시 이미 계산한 파일들을 반환한다.
Lazy.force(getFiles) -> Js.log

// 아니면 이미 존재하는 함수를 lazy로 래핑할 수 있다.
let getFiles1 = () => {
  Node.Fs.readdirSync("./pages")
}

// 지연된 값으로 함수를 래핑한다
let lazyGetFiles = Lazy.from_fun(getFiles1)

/* 인자가 있는 함수를 래핑하는 예 */
let doesFileExist = name => {
  Node.Fs.readdirSync("./pages") -> Js.Array2.find(s => name === s)
}

/* Lazy 문법을 다시 사용. */
/* 여기서는 Lazy.from_fun을 사용할 수 없다. */
let lazyDoesFileExist = lazy(doesFileExist("blog.res"))
```

##### Async & Promise
- 현재 ReScript 에서는 `async`및 `await`키워드를 지원하지 않는다.
- 최신 `Promise` 바인딩은 현재 표준 라이브러리의 일부가 아니다. 지금은 별도로 설치 필요.
- https://github.com/ryyppy/rescript-promise#usage

```reason
open Promise
Promise.resolve("hello world")
-> then(msg => {
  resolve("Message: " ++ msg)
})
-> then(msg => {
  Js.log(msg);
  resolve()
})
-> ignore
```

### ⚡ 아쉬운 점 및 회고
첫 task를 받아서 오늘은 디자이너, 백앤드, 프론트, PO 4명이서 디자인 리뷰가 있었고 회의는 40분? 정도 했던거 같은데 재밌었다. 느꼈던건 이렇게 모여서 이야기하니까 빠르게 어떤 부분에서 서로의 생각이 다른지에 대해서 알수가 있었다. 각자의 사람이 이해하는 방식도 다르고, 생각하는 방식도 다른게 당연하다. 서로 의견을 내면서 조율해가면서 그 과정이 꽤 재밌었고, 전체적인 흐름을 잡기에 너무 좋았던 자리였다.   

첫 테스크라 기한이 없는 테스크라 부담도 적고 이번 테스크는 어떻게 흘러가는지를 아는것에 목적이 있다. 어떤 방식으로 작업을 나누고 그에 대한 브랜치를 나누고, 어떻게 이슈화를 하며, 지속적인 flow를 따라가는게 목적이다. 그렇기에 모르면 지속적으로 물어보고 계속 커뮤니케이션해야한다. 확실한건 SI회사에 다녔던 방식과 완전히 다르고, 소통이 매우 매우 많아졌다. 내가 원하던 방식.. 프로그래머는 단순히 개발만하는게 아니다..   

오늘 명함을 받았다. 명함을 받았으니. 하려고 했던게 이직 회고를 작성하는 것이다. 이번주는 이직 회고를 작성해보자.   

오늘 스터디가 꽤 길었다. 거의 2시간가까이 걸렸는데, 피곤했지만, 주제 자체가 할 이야기도 많았고, 이걸 어떻게 프론트에서 적용할지에 대해서 얘기를 하니 시간이 금방가버렸다. 나름 재밌었다.   

재택을 하고 싶은데 확실히 회사를 나가는게 적응은 빠르고 나름 또 회사 나와서 다른 분들과 얘기하는게 재밌어서 그냥 이번주도 나가는 방향으로 생각해야겠다.

오늘 잘 못한점은 쓸대없이 눈치보는 습관..   이렇게 해도 될까? 라는게 결국은 다 되는거니까 눈치 보지말고 그냥 하자.

### 🚀 내일 할 일
- ReScript 공식 문서 훑어보기
- 블로그에 이직 후기 회고 작성

### 🎯 이번주 목표
- 회사 문화에 적응하기
- 스터디 참여 및 오브젝트 10장까지 읽기
- 스터디를 위한 자바스크립트 코딩의 기술 훑어보기
- ReScript 공식 문서 훑어보기
- 블로그에 이직 후기 회고 작성
