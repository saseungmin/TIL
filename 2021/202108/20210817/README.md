## 📆 2021-08-17(화) TIL

### 📈 어제의 계획이 예상대로 진행됐나요?
- [x] 오브젝트 4장 읽고 스터디 참여
- [x] [ReScript 공식문서 훑어보기](https://github.com/saseungmin/Learn_ReScript_with_Official_Documentation)
- [x] ReScript Korean Repository에 Contribution
  - [PR](https://github.com/green-labs/rescript-in-korean/pull/40)
- [x] 자취에 필요한 물건들 사기

### 🦄 이번주 목표 진행사항은요? (오늘 조금이라도 진행했으면 체크)
- [x] 스터디 참여 및 오브젝트 6장까지 읽기
- [ ] reading_books_record_repository 사이트에 정리한 책 추가하기
- [x] ReScript 공식문서 훑어보기
- [ ] 서울로 이사 준비 및 입사 준비!
- [x] 자취에 필요한 물건들 사기
- [ ] 보험 처리 끝내기

### 🤔 공부하면서 배운것이 있다면?

#### 🎈 오브젝트 4장
##### 캡슐화
변경될 가능성이 높은 부분은 구현, 상대적으로 안정적인 부분을 인터페이스   
캡슐화는 외부에서 알 필요가 없는 부분을 감춤으로써 대상을 단순화하는 추상화의 한 종류이다.   
캡슐화가 중요한 이유는 불안정한 부분과 안정적인 부분을 분리해서 변경의 영향을 통제할 수 있기 때문이다.   

##### 응집도와 결합도
모듈 내의 요소들이 하나의 목적을 위해 긴밀하게 협력한다면 그 모듈은 높은 응집도를 가진다.    
결합도는 의존성의 정도를 나타내며 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지를 나타내는 척도이다. 다른 모듈에 대해 너무 자세하게 알고 있다면 높은 결합도를 가진다.   

높은 응집도와 낮은 결합도를 가진 설계를 추구해야 하는 이유는 설계를 변경하기 쉽게 만들기 때문이다.

##### 데이터 중심 시스템의 문제점
1. 캡슐화를 위반한다.

다음 데이터 중심으로 설계한 `Movie` 클래스는 오직 메서드를 통해서만 객체의 내부 상태에 접근할 수 있어 캡슐화를 위반하지 않아보이지만, **접근자와 수정자 메서드는 객체 내부의 상태에 대한 어떤 정보도 캡슐화하지 못한다.**

```java
public class Movie {
  // Movie 내부에 Money 타입의 fee라는 이름의 인스턴스 변수가 존재한다는 사실을 
  // 퍼블릭 인터페이스에 노골적으로 드러낸다.
  private Money fee;

  public Money getFee() {
    return fee;
  }

  public void setFee(Money fee) {
    this.fee = fee;
  }
}
```

위와 같은 원인은 객체가 수행할 책임이 아니라 내부의 저장할 데이터에 초점을 맞췄기 때문이다. 이러한 접근자와 수정자에 과도하게 의존하는 설계 방식은 **추측에 의한 설계 전략**이라 부른다. 이 전략은 객체가 사용될 **협력을 고려하지 않고**, 객체가 다양항 상황에서 사용될 수 있을 것이라는 막연한 추측을 기반으로 설계를 진행한다. 때문에 **위와 같이 과도한 접근자와 수정자 메서드는 사용해서는 안된다.**   

2. 높은 결합도
3. 낮은 응집도

##### 해결방법은?
객체가 스스로의 상태를 책임져야 하고 외부에서는 인터페이스에 정의된 메서드를 통해서만 상태에 접근할 수 있어야 한다.
- 이 객체가 어떤 데이터를 포함해야 하는가?
- 이 객체가 데이터에 대해 수행해야 하는 오퍼레이션은 무엇인가?

##### 데이터 중심 설계의 문제점
데이터 중심의 설계가 변경에 취약한 이유는 두 가지다.
- 본질적으로 너무 이른 시기에 데이터에 관해 결정하도록 강요한다.
- 데이터 중심의 설계에서는 **협력이라는 문맥을 고려하지 않고** 객체를 고립시킨 채 오퍼레이션을 결정한다.

데이터 중심 설계의 객체의 행동보다는 상태에 초점을 맞춘다.   
데이터 중심 설계는 객체를 고립시킨 채 오퍼레이션을 정의하도록 만든다.   

#### 🎈 ReScript
##### 흥미로웠던 것들   

- record

기본적으로 불변이다. 고정된 필드를 가지고 있다. 레코드는 반드시 타입 선언을 해야한다.

```rs
type person = {
  age: int,
  name: string
}

// 신기한건 타입을 명시적으로 선언하지 않아도 가장 가까운 타입을 찾아 추론한다.
let me = {
  age: 5,
  name: "Big ReScript"
}

// 다만 다른 파일이나 모듈에 있을 경우 명시적으로 기재
let me: School.person = {
  age: 20, 
  name: "Big ReScript",
}
```

- object

리스크립트 객체는 레코드와 비슷하지만, 타입 선언 불필요, 레코드와 다르게 구조적이고 더 다형성을 가지고 있다.   
객체가 JS로부터 전달된 것이 아니면 변경할 수 없다. 패턴매칭을 지원하지 않는다.

```rs
// 필드 이름이 따옴표
// 객체는 타입 선언을 굳이 적을 필요가 없다.
type person = {
  "age": int,
  "name": string,
}

// 레코드와 다르게 여기서 me는 "age", "name" 필드가 있는 타입 선언을 찾아서 비교하려 하지 않는다.
let me = {
  "age": 5,
  "name": "Big ReScript",
}

let age = me["age"]
```

### ⚡ 아쉬운 점 및 회고
역시 문서를 읽다보면 잘못된 링크나 오탈자 또는 누락된 사항이 보인다. 그 부분을 찾은걸로 끝나지 않고, 오픈 소스에 컨트리뷰트하는 습관을 들이자. 그만큼 나도 도움받은 부분이 많으니.. 그리고 이런 하나하나가 결국 협업을 잘하기 위해서라 생각한다. 두려움을 없애는 지름길 같은거랄까..? 그래서 오늘도 리스크립트 문서를 읽으며 간단한 링크하나를 수정했다.😊   

스터디를 하면서 이런저런 얘기가 오갔다. 객체지향 책이지만 프론트엔드 개발자인만큼 관련되서 어떻게 적용할 수 있을까에 대해서 여러 이야기를 했다. 느꼈던건 우리는 객체 지향 속에서 리액트를 사용하고 있었다는 점을 알게 되었다. 우리는 객체 지향을 몰랐다면 리액트를 "그냥" 사용했었겠지만, 그 리액트 라이브러리 안에는 결국 객체지향적인 요소들이 곳곳에 숨어있었다. 간단하게 props로 넘겨 필요한 의존성만 전달하여 내부의 구현을 숨기는 캡슐화, Redux를 사용함으로써 결합도를 줄이는 방법. 커스텀 훅을 사용하여 제어에 역전을 사용하는 것등등.. 이런 좋은 설계를 하기 위해서 결국 한 컴포넌트에 한가지의 책임을 가지도록 하는 단일 책임 원칙. 그래서 이런 설계를 잘하기 위해서 나는 스터디를 이렇게 말했다. 결국 우리는 객체의 상태를 먼저 생각하는 설계가 아닌 어느정도의 규모가 있는 도메인부터 생각하여 객체의 행동, 협력을 포함하는 문맥에서 바라보라는 것이라고. 또한, 이런 객체의 행동부터 생각하기 위해서 사고방식을 바꾸고 노력해야한다고 말했고, 책에서 얘기한 것을 활용해볼 필요가 있다고 했다. 예를 들어 CRC 방법. 스터디원 한 분께서 이번 챕터를 읽으며 키보드에 바로 손을 올리는 습관을 고쳐야겠다라고 말했다. 이 말에 동의했다. 나도 반성하는 부분이다.. 😅 데이터 주도 설계가 아닌 책임 주도 설계를 하자!   

아! 반성할 점은 잠좀 줄이자. 이제 아침에 일어나야하잔니! 😵

### 🚀 내일 할 일
- ReScript 공식문서 훑어보기
- 자취에 필요한 물건들 사기: 책상 구매하기
- 보험 처리 끝내기
- 입사 서류 관련하여 전 회사에 다시 전화 및 현 회사의 인사담당자님께 물어보기

### 🎯 이번주 목표
- 스터디 참여 및 오브젝트 6장까지 읽기
- reading_books_record_repository 사이트에 정리한 책 추가하기
- ReScript 공식문서 훑어보기
- 서울로 이사 준비 및 입사 준비!
- 자취에 필요한 물건들 사기
- 보험 처리 끝내기
